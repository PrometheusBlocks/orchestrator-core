# orchestrator-core Agent Development Guide

**Last Updated:** May 16, 2025

## 1. Project Explanation

`orchestrator-core` is a Python-based system designed to orchestrate "PrometheusBlocks" utilities. These utilities are modular pieces of code, each defined by a `utility_contract.json` file. The orchestrator aims to simplify the process of discovering, combining, and setting up projects that use these blocks.

**Core Workflow:**

1.  **Discovery (Catalog):** The system can discover available utilities from:
    *   A local registry (managed via `registry_cli`).
    *   The `PrometheusBlocks` GitHub organization, by searching for `utility_contract.json` files. During GitHub discovery, the source repository URL for each utility is captured.
2.  **Planning:** A user provides a natural language prompt describing a desired task.
    *   The `Planner` (currently using an LLM like GPT-4 via `orchestrator_core.planner.parser`) analyzes the prompt and consults the catalog of known utilities.
    *   It outputs a `plan.json` file, which lists:
        *   `resolved` utilities: Existing utilities that can fulfill parts of the prompt.
        *   `missing` utilities: Capabilities required by the prompt for which no existing utility is found.
        *   Optionally, `proposed_utilities`: Suggested contracts for the `missing` utilities, generated by the LLM.
3.  **Scaffolding:** Based on the `plan.json`, the `Scaffolder` (`orchestrator_core.executor.scaffolder`) sets up a local project directory:
    *   For `resolved` utilities: If their source repository URL was discovered via GitHub, their actual source code is cloned into the project. If the URL is unknown (e.g., for a purely local utility), cloning is skipped with a warning.
    *   For `missing` utilities: A new utility structure is scaffolded using a generic block template (e.g., `https://github.com/PrometheusBlocks/block-template`). A placeholder `utility_contract.json` is generated, which can be overwritten by a more detailed contract from the `proposed_utilities` section of the `plan.json` if provided.
4.  **Execution (Future):** The next major phase will be to execute the orchestrated plan, running the utilities in the scaffolded project, managing their dependencies, and handling data flow between them.

**Key Components:**

*   **`UtilityContract` (`contracts/utility_contract.py`):** A Pydantic model defining the schema for `utility_contract.json`. This contract is crucial for interoperability and **must not be changed to maintain backward compatibility.**
*   **Catalog (`orchestrator_core/catalog/`):** Manages the list of known utilities, loading them from local and remote (GitHub) sources.
*   **Planner (`orchestrator_core/planner/`):** Converts user prompts into structured plans.
*   **Scaffolder (`orchestrator_core/executor/scaffolder.py`):** Creates project structures.
*   **CLI (`orchestrator_core/cli.py`):** Provides command-line access to functionalities like `list`, `show`, `plan`, and `scaffold`.
*   **API (`orchestrator_core/api/`):** Offers an HTTP interface (e.g., for `/plan`).

## 2. Coding Standards

*   **Language:** Python 3.9+
    *   **Type Hinting:** All new code should use type hints.
    *   **Pydantic:** Used for data validation and settings management, especially for `UtilityContract`.
*   **Style:** Adhere to PEP 8. Use a linter/formatter like Black or Ruff.
*   **Testing:**
    *   Use `pytest` for unit and integration tests.
    *   Aim for high test coverage for new features.
    *   Place tests in the `tests/` directory, mirroring the project structure.
*   **Documentation:**
    *   **Docstrings:** Use Google-style docstrings for all modules, classes, and functions.
    *   **Markdown:** Project-level documentation (like this file, `README.md`, sprint plans) should be in Markdown.
*   **Version Control (Git):**
    *   Follow conventional commit message formats (e.g., `feat: ...`, `fix: ...`, `docs: ...`).
    *   Create feature branches for new development.
    *   Ensure `main` branch is always stable.
*   **Immutability of Core Contracts:** The `UtilityContract` Pydantic model in `orchestrator_core/contracts/utility_contract.py` is considered stable. No breaking changes are allowed to ensure backward compatibility with existing utilities. New fields can be added if they are optional.
*   **Logging:** Use the standard Python `logging` module. Provide clear and informative log messages.
*   **Dependencies:** Manage dependencies using `requirements.txt`.

## 3. Current Project Status (as of May 16, 2025)

The project has successfully completed the "Scaffolding Sprint" (see `ScaffoldingSprint.md`).

**Key Capabilities Implemented:**

*   **Utility Contract Definition:** Stable Pydantic model (`contracts/utility_contract.py`).
*   **Utility Registry & Discovery:**
    *   Local registry CLI (`registry_cli/cli.py`).
    *   Catalog system (`orchestrator_core/catalog/`) loads local specs and fetches `utility_contract.json` files from GitHub.
    *   The `github_client.py` captures the `_source_repository_url_discovered` for utilities found on GitHub.
*   **Planning Engine:**
    *   `orchestrator_core/planner/parser.py` uses an LLM (OpenAI's GPT models) to parse prompts into `plan.json`, identifying "resolved" and "missing" utilities. It can also propose contracts for missing utilities.
    *   Fallback to keyword-based planning if LLM fails.
*   **Scaffolding Engine (`orchestrator_core/executor/scaffolder.py`):**
    *   `clone_repository()`: Clones Git repositories (for resolved utilities and the generic template) and removes the `.git` directory.
    *   `customize_new_utility_from_template()`: Customizes the generic block template for new/missing utilities, replacing placeholders and generating a basic `utility_contract.json`.
    *   `scaffold_project()`:
        *   Creates a project directory.
        *   Clones resolved utilities using their `_source_repository_url_discovered`.
        *   Scaffolds missing utilities from the `generic_block_template_url`.
        *   Handles cases where `_source_repository_url_discovered` might be missing for a resolved utility (logs a warning and skips cloning).
        *   Can use detailed contracts from `plan.json`'s `proposed_utilities` to overwrite the placeholder contract for new utilities.
*   **Interfaces:**
    *   CLI (`orchestrator_core/cli.py`): `list`, `show`, `plan`, `scaffold` commands are functional. The `scaffold` command can ingest different `plan.json` formats.
    *   API (`orchestrator_core/api/main.py`): `/plan` endpoint is available.
*   **Testing:**
    *   Unit tests for catalog, executor (scaffolder), GitHub client (requests-based), and planner parser are in place (`tests/`).
    *   Tests verify the capture and use of `_source_repository_url_discovered`.
*   **Documentation:** `README.md` and sprint planning documents (`ScaffoldingSprint.md`, `CodePlan.md`) are updated.

**Areas for Minor Refinement (from previous review):**

*   **Branch Discovery for Cloning:** The scaffolder currently assumes the default branch for cloning resolved utilities. Explicitly capturing and using `_source_repository_branch_discovered` (e.g., the default branch name from GitHub API) could be a minor enhancement.
*   **CLI Usability:** The `plan` command directly overwrites `plan.json`. Adding an `--output` option or confirmation prompt could improve user experience.

## 4. Next Features & Sprints

The primary focus now shifts to enabling the **execution** of the orchestrated plans.

### Sprint 1: Execution Engine - Phase 1 (Core Invocation & Dependency Setup)

*   **Goal:** Implement the foundational ability to execute a single utility's entrypoint within a scaffolded project, including basic dependency management.
*   **Key Tasks:**
    1.  **Design Executor Module:** Create `orchestrator_core/executor/runner.py` (or similar) to house the execution logic.
    2.  **Utility Invocation Mechanism:**
        *   Develop a robust way to dynamically load and call a specified entrypoint function within a utility's code (likely Python functions initially). This will involve inspecting the `utility_contract.json` for entrypoint definitions.
        *   Handle parameter passing to the entrypoint, potentially from a dedicated section in an enhanced `plan.json` or a new execution manifest.
        *   Capture `stdout`, `stderr`, and return values from the executed utility.
    3.  **Basic Dependency Management:**
        *   For each utility in the scaffolded project, assume it has its own `requirements.txt`.
        *   Implement logic to create a dedicated virtual environment for the project (or per utility, TBD) and install its dependencies before execution. This ensures isolation.
    4.  **CLI for Single Utility Execution:** Add a new CLI command, e.g., `orchestrator-core execute <project_name_or_path> --utility <utility_id> --entrypoint <entrypoint_name> [--params_json <json_string_or_file>]`.
*   **Definition of Done:**
    *   `Executor` module (`runner.py`) is created with core invocation logic.
    *   The new `execute` CLI command can successfully run a specified entrypoint of a single utility within a scaffolded project, installing its dependencies in an isolated environment.
    *   Output (stdout, stderr, return value) from the utility can be captured and displayed.
    *   Unit tests for the core invocation and dependency installation logic.
    *   Documentation for the new execution capability and CLI command.

### Sprint 2: Execution Engine - Phase 2 (Plan Execution & Data Flow)

*   **Goal:** Enable the execution of a full sequence of utilities as defined in a `plan.json` (or an execution manifest derived from it), managing basic data flow between them.
*   **Key Tasks:**
    1.  **Plan-Driven Execution:**
        *   Extend the `Executor` to parse the `resolved` (and potentially `missing` if they were to be stubs) utilities from a `plan.json`.
        *   Determine the execution order (initially sequential, following the order in the plan or a defined sequence).
    2.  **Inter-Utility Data Flow:**
        *   Design and implement a mechanism for passing output from one utility as input to the next. This should leverage the `parameters_schema` and `return_schema` defined in the `utility_contract.json` files.
        *   Consider a shared context or a simple data bus for the duration of the plan execution.
    3.  **Execution Manifest (Optional but Recommended):** Consider if `plan.json` is sufficient or if a more detailed "execution manifest" should be generated from the plan, specifying exact entrypoint calls, parameter mappings, and execution order.
    4.  **Update CLI:** Enhance the `execute` command to accept a `plan.json` (or project path containing one) to run the full orchestrated sequence.
*   **Definition of Done:**
    *   The `Executor` can run a sequence of utilities as defined by a plan.
    *   Demonstrable data flow: output from `utility_A` is correctly passed as input to `utility_B`.
    *   The `execute` CLI command can orchestrate a multi-utility plan.
    *   Comprehensive tests for plan execution, including data flow.
    *   Documentation updated for plan-level execution.

### Sprint 3: API Enhancements, Refinements & Advanced Features

*   **Goal:** Expose core functionalities (scaffolding, execution) via the API, refine existing features based on learnings, and explore advanced execution capabilities.
*   **Key Tasks:**
    1.  **API Endpoints:**
        *   Implement a `/scaffold` API endpoint that accepts a plan and triggers project scaffolding.
        *   Implement an `/execute` API endpoint that accepts a project identifier or plan and triggers execution.
    2.  **Scaffolding Refinements:**
        *   If not done earlier, implement capture and use of `_source_repository_branch_discovered` in `github_client.py` and `scaffolder.py` for more precise cloning.
        *   Improve CLI usability for `scaffold` and `plan` commands (e.g., `--output` options, overwrite confirmations).
    3.  **Advanced Execution (Exploratory):**
        *   Investigate support for non-Python utilities (e.g., via Docker containers if contracts define them).
        *   Explore concepts of parallel execution for independent plan steps.
        *   More sophisticated state management during execution.
    4.  **Logging and Error Handling:** Conduct a thorough review and enhancement of logging and error handling across the entire application.
*   **Definition of Done:**
    *   New `/scaffold` and `/execute` API endpoints are functional, documented (e.g., OpenAPI spec), and tested.
    *   Scaffolder can use specific branch information if available.
    *   CLI usability improvements are implemented.
    *   At least one advanced execution feature is prototyped or designed.
    *   Logging and error reporting are significantly improved.

This roadmap provides a clear path forward, focusing on delivering a robust execution engine as the next major milestone for `orchestrator-core`.